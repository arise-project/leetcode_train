permutation = any of the different ways in which a set of things can be ordered
combination = two or more things joined or mixed together to form a single unit
lexicographic = (sorted) order
backtrack =  to go back along the same route that you have just come along

In permutations the number of items is always the same where it’s not the case for combination.

Permutation = Count = n! =  1 * 2 * 3 * …* x
a, b, c	
a, c, b
b, a, c
b, c, a
c, a, b
c, b, a
Combination = Count = 2pow(n) = the power set
a
b
c
a, b
b, c
c, a
a, b, c

Single threaded  = lexicographic order
multithreaded  = not ordered because faster for performance

-------------------------
Permutation all algo = https://github.com/EricOuellet2/Permutations
------------------------
Theory: https://www.baeldung.com/cs/array-generate-all-permutations

Heap's algorithm = it generates each permutation from the previous one by interchanging a single pair of elements. 
that it was at that time the most effective algorithm for generating permutations by computer
it produces every possible permutation of these elements exactly once.

Author = Ouellet	Algo name = OuelletHeap	Based on algorithm = Heap Lex1 = No	Threadable2 = No	Comment

Ouellet Indexed = Multithread = max 20 elements = 20! permutations

void heapPermutation(int a[], int size, int n)
{
    // if size becomes 1 then prints the obtained
    // permutation
    if (size == 1) {
        printArr(a, n);
        return;
    }
 
    for (int i = 0; i < size; i++) {
        heapPermutation(a, size - 1, n);
 
        // if size is odd, swap 0th i.e (first) and
        // (size-1)th i.e (last) element
        if (size % 2 == 1)
            swap(a[0], a[size - 1]);
 
        // If size is even, swap ith and
        // (size-1)th i.e (last) element
        else
            swap(a[i], a[size - 1]);
    }
}

https://www.geeksforgeeks.org/heaps-algorithm-for-generating-permutations/
------------------------------

lexicographic

Following are the steps to print the permutations lexicographic-ally

1. Sort the given string in non-decreasing order and print it. The first permutation is always the string sorted in non-decreasing order.

2. Start generating next higher permutation. Do it until next higher permutation is not possible. If we reach a permutation where all characters are sorted in non-increasing order, then that permutation is the last permutation.

Steps to generate the next higher permutation:
1. Take the previously printed permutation and find the rightmost character in it, which is smaller than its next character. Let us call this character as ‘first character’.

2. Now find the ceiling of the ‘first character’. Ceiling is the smallest character on right of ‘first character’, which is greater than ‘first character’. Let us call the ceil character as ‘second character’.

3. Swap the two characters found in above 2 steps.

4. Sort the substring (in non-decreasing order) after the original index of ‘first character’.

https://www.geeksforgeeks.org/lexicographic-permutations-of-string/

---------------

unique subsets

---------------

to make subsets unique it sghould be lexagraphical sorted

---------------

---------------


subsets

---------------

Theory https://afteracademy.com/blog/print-all-subsets-of-a-given-set

int S[N]
void allSubsets(int pos, int len, int[] subset) 
{
  if(pos == N) 
  { 
     print(subset)
     return
  }
  // Try the current element in the subset.
  subset[len] = S[pos]
  allSubsets(pos+1, len+1, subset)
  // Skip the current element.
  allSubsets(pos+1, len, subset)
}

---------------

Subsed of size

---------------

super set

private static void getSubsets(List<Integer> superSet, int k, int idx, 
            List<Integer> current, List<List<Integer>> solution) {

        if (current.size() == k) {
            solution.add(new ArrayList<>(current));
            return;
        }

        for (int i = idx; i < superSet.size(); i++) {
            Integer x = superSet.get(i);
            current.add(x);
            getSubsets(superSet, k, i + 1, current, solution);
            current.remove(current.size() - 1);
        }
    }

    
------------------

topologicsl sorting

------------------

is sequence of vertices in graph in deep first traverse. Only exit from vertex meke it topological

